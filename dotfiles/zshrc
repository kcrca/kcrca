bindkey -v			# vi

export FCEDIT=vi		# Default editor for the fc command

HISTSIZE=300
SAVEHIST=300
HISTCHARS=!,#
HISTFILE=~/.zsh_history

FIGNORE='~:.bak:.o:CVS'		# Ignore during file completion

build_prompt() {
    # The prompt format is :user@host[vcs_info]:

    # If the user is known/expected, "user@" is ommitted (RP_BEFORE)
    RP_BEFORE=
    if [[ $USER != arnold && $USER != root && $USER != kcrca ]]; then
	RP_BEFORE="%U%n%u@"
    fi

    # If there is no useful vcs info, "[vcs_info]" is ommited (RP_AFTER)
    RP_AFTER=
    if [[ -n $VIRTUAL_ENV ]]; then
	RP_AFTER="["`basename $VIRTUAL_ENV`"]"
    fi
    #if which g4client > /dev/null && G4_CLIENT=`g4client`; then
	#export G4_CLIENT
	#RP_AFTER="$RP_AFTER[$G4_CLIENT]"
    #fi
    vcs_info
    if [[ $vcs_info_msg_0_ != "" ]]; then
	# Remove a trailing slash, which means "no branch"
	RP_AFTER="${RP_AFTER}[${vcs_info_msg_0_%/}]"
    fi

    local i up rp
    for (( i = 0; i < SHLVL; i++ )) do
	up="$up>"
	rp="$rp#"
    done
    PROMPT="%h%(!. $rp.$up) "
    RPROMPT="%(0?..%S***%s ):$RP_BEFORE%m%B$RP_AFTER%b:"
}

autoload -Uz vcs_info
zstyle ':vcs_info:*' formats '%r/%b'
zstyle ':vcs_info:*' actionformats '%r/%b'

#zstyle ':vcs_info:*' actionformats 's:%s, b:%b, a:%a, i:%i, c:%c, u:%u, R:%R, r:%r, S:%S, m:%m'
#zstyle ':vcs_info:*'       formats 's:%s, b:%b, i:%i, c:%c, u:%u, R:%R, r:%r, S:%S, m:%m'
#zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'

build_prompt

zstyle -d ':cmd_notify:'
zstyle ':cmd_notify:' notify-time 15
zstyle ':cmd_notify:' ignore-cmd man vl vi ex vim
zstyle ':cmd_notify:' silent-frontmost Terminal
zstyle ':cmd_notify:' frontmost-command frontmost

#if which growlnotify >&/dev/null ; then
if false ; then
    # This code used to work for me on the mac to pop up notification (via
    # growl) when a command that had been runnning in the shell finishes *IF*
    # it took more than a certain time. This let me run things in a shell and
    # go do something else until it finished. This broke with some release,
    # and I if'ed this out until I could fix it. The idea is that preexec
    # remembers the command being run and the start time, and long_cmd_notify
    # (also run before the prompt and before preexec) would do a notification
    # if the time was too long. I started to generalize it so it could be
    # loaded like any other zsh function, and configured to use other tools
    # to notify.
    #
    # Broken, needs fixing someday.
function preexec() {
    emulate -L zsh
    local -a cmd
    cmd=(${(z)1})             # Re-parse the command line

    # Handle job control (thanks to hardescape script)
    case $cmd[1] in
    fg|bg|job|%*)
	# Look up the command that is being managed by fg, etc.
	local jobspec
	if [[ $cmd[1] == 'fg' ]]; then
	    if (( $#cmd == 1 )); then
		jobspec="%+"
	    else
		jobspec=$cmd[2]
	    fi
	else
	    jobspec=$cmd[1]
	fi

	#
	# I tried just using 'jobs -l' to translate the spec into a command, but
	# I couldn't capture the output.  That is,
	#     jobs -l %1 | cat
	# would result in the error "jobs: %1: no such job".  So I'm parsing things
	# myself.  This seems like a bug, since "jobs | cat" works just fine.
	#

	local cmd_text

	jobspec=${jobspec/\%/}
	case $jobspec in
	[0-9]*)
	    cmd_text=$jobtexts[$jobspec]
	    ;;
	[-+])
	    local -i i
	    i=0
	    for cmd_text in $jobstates; do
		i=$(( $i + 1 ))
		if [[ $cmd_text != ${cmd_text/:$jobspec:/} ]]; then
		    cmd_text=$jobtexts[$i]
		    break
		fi
	    done
	    ;;
	*)
	    for cmd_text in $jobtexts; do
		if [[ $cmd_text != ${cmd_text%$jobspec} ]]; then
		    break
		fi
	    done
	    ;;
	esac
	cmd=(${(z)cmd_text})
	;;
    *)
	;;	# do not need to look up the command
    esac

    zstyle ':cmd_notify:' command "$cmd[@]"

    # ARGH!!!  There is a zsh bug: If there is a preexec function, the elapsed
    # times for the history are wrong.  So I have to do elapsed time by myself.  Feh.
    # http://www.zsh.org/mla/workers/2007/msg01246.html

    zstyle ':cmd_notify:' start-time `date +%s`
}

# If something takes at least :cmd_notify:notify-time seconds, use growl to notify if Terminal not in foreground
function long_cmd_notify() {
    result=$?
    if zstyle -T ':cmd_notify:' start-time; then
    	return 0
    fi

    # I used to use the commented-out code below, but a bug in zsh broke it (see preexec)
    # working.  I leave it in because it should be faster, so if the bug gets fixed...
    # hist=(`fc -l -D -n -1 -1`)
    # tm=$hist[1]:s/://

    local -i stop start tm notify
    local cmd
    stop=`date +%s`
    zstyle -s ':cmd_notify:' start-time start
    tm=$(($stop - $start))

    zstyle -s ':cmd_notify:' notify-time notify
    if (( $tm >= $notify )); then
	local -a cmd
	zstyle -a ':cmd_notify:' command cmd
	if zstyle -m ':cmd_notify:' ignore_cmd $cmd[1]:t; then
	    :	# it doesn't matter how long these took
	else
	    local fmc fm
	    zstyle -g fmc ':cmd_notify:' frontmost-command
	    fm=`eval $fmc`
	    if zstyle -m ':cmd_notify:' silent-frontmost $fm; then
		: # Be silent about commands if this is frontmost
	    else
		local -i secs=$(($tm % 60))
		local -i mins=$(($tm / 60))
		local timestr
		timestr=`printf 'Time: %d:%02d' $mins $secs`
		echo Time: $timestr / Frontmost: $fm
		(
		    echo $timestr
		    echo Status: $result
		) | growlnotify -s -- "$cmd[@]"
	    fi
	fi
    fi
    # reset the timing
    zstyle -d ':cmd_notify:' start-time
}
else
unfunction long_cmd_notify 2>&/dev/null
unfunction preexec 2>&/dev/null
fi

precmd_functions=(build_prompt long_cmd_notify)

unset RP_BEFORE RP_AFTER

chdir $PWD	# force the change_header (and make it right)

stty intr '^C' erase '^H' kill '^U' quit '^\\' eof '^D' susp '^Z' lnext '^V' stop '^S' start '^Q'
stty -a | grep -q dsusp && stty dsusp '^Y'

# virtualenv for python development
export WORKON_HOME=$HOME/.virtualenvs
test -f /Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenvwrapper.sh && source /Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenvwrapper.sh

# My custom stuff to update the prompt on virtualenv change

test -f /etc/bash_completion.d/g4d && source /etc/bash_completion.d/g4d

# The following lines were added by compinstall

zstyle ':completion:*' completer _complete _ignored
zstyle :compinstall filename ~/.zshrc

autoload -Uz compinit
compinit
which bashcompinit >/dev/null && bashcompinit
# End of lines added by compinstall

# Quote URL's on the command line automatically
autoload -U url-quote-magic
zle -N self-insert url-quote-magic

# cdr command to remember chdir stack between sessions
autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
add-zsh-hook chpwd chpwd_recent_dirs

# This is my version of cdr, which also accepts "cd foo" and looks for a dir
# named "foo" in the directory list, or -g and looks for a regexp (grep)
cdr () {
	emulate -L zsh
	setopt extendedglob
	autoload -Uz chpwd_recent_filehandler chpwd_recent_add
	integer list set_reply i bad edit grep
	local opt dir
	local -aU dirs
	while getopts "elrg" opt
	do
		case $opt in
			(e) edit=1  ;;
			(l) list=1  ;;
			(r) set_reply=1  ;;
			(g) grep=1 ;;
			(*) return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	if (( set_reply ))
	then
		typeset -ga reply
	else
		local -a reply
	fi
	if (( list || set_reply || edit ))
	then
		(( $# )) && bad=1 
	else
		if [[ $#1 -eq 0 ]]
		then
			1=1 
		elif [[ $# -ne 1 || $1 != <-> ]]
		then
			if zstyle -t ':chpwd:' recent-dirs-default
			then
				cd "$@" return
			fi
		fi
	fi
	if (( bad ))
	then
		print "Usage: $0 [-l | -r | <dir-num> ]
Use $0 -l or completion to see possible directories."
		return 1
	fi
	chpwd_recent_filehandler
	if [[ $PWD != $reply[1] ]]
	then
		chpwd_recent_add $PWD && chpwd_recent_filehandler $reply
	fi
	if (( edit ))
	then
		local compcontext='directories:directory:_path_files -/'
		IFS='
' vared reply || return 1
		chpwd_recent_filehandler $reply
	fi
	[[ $reply[1] = $PWD ]] && reply=($reply[2,-1]) 
	if (( list ))
	then
		dirs=($reply) 
		for ((i = 1; i <= ${#dirs}; i++ )) do
			print -n ${(r.5.)i}
			print -r ${(D)dirs[i]}
		done
		return
	fi
	(( set_reply || edit )) && return
        if [[ $1 == <-> ]]
        then
                if (( $1 > ${#reply} ))
                then
                        print "Not enough directories ($(( ${#dirs} - 1)) possibilities)" >&2
                        return 1
                fi
                dir=${reply[$1]} 
        else
		local rd
		dirs=($reply) 
		for ((i = 1; i <= ${#dirs}; i++ )) do
		    	rd=$reply[$i]
		    	if (( grep ))
			then
			    	if [[ $rd =~ $1 ]]
				then
				    	dir=$rd
					break
				fi
			elif [[ ${rd:t} == $1 ]]
			then
				dir=$rd
				break
			fi
		done
		if [[ -z $dir ]]
		then
			print "Cannot find named dir: $1" >& 2
			return 1
		fi
        fi
	if zstyle -t ':chpwd:' recent-dirs-pushd
	then
		pushd -- $dir
	else
		cd -- $dir
	fi
}

# My addition to cdr: Does a pushd equivalent this time
pdr() {
	emulate -L zsh
        if zstyle -t ':chpwd:' recent-dirs-pushd
        then
                cdr "$@"
        else
                local x
                zstyle -s ':chpwd:' recent-dirs-pushd x
                zstyle ':chpwd:' recent-dirs-pushd "true"
                cdr "$@"
                zstyle ':chpwd:' recent-dirs-pushd "$x"
        fi
}

func zshhist_path() {
	local f
	if [[ $LC_TTY == "" ]]; then return; fi
	f=~/.zsh_hist/${LC_TTY:gs,/,_}
	f=${f:s,/_,/}
	echo $f
}

func zshhist_store() {
	local f
	f=`zshhist_path`
	if [[ $f == "" ]]; then return; fi
	if [[ ! -d ~/.zsh_hist ]]; then return; fi
	(
	    [[ $d != "" ]] && echo g4dir $t/$d >> $f
	    echo cd $PWD
	) >! $f
}

export LC_TTY=${LC_TTY:-`tty`}

domain_source zshrc
