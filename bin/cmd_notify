#!/bin/zsh

tty=$TTY:t
if [[ $1 == -t ]]; then
	tty=$2
	shift 2
fi

tm=$1 ; shift
st=$1 ; shift
cmd=("$@")
if [[ $cmd == "-" ]]; then
    read -A cmd
fi

if zstyle -m ':cmd_notify:' ignore-cmd "$cmd[1]:t"; then
    # it doesn't matter how long these took
    exit 0
fi

# This means I'm running remotely, and should send it back to the home machine
if [[ ! -z $REMOTE_HOST && ! -z $LC_TTY ]]; then
    # This used to send back a remote notification, but with gnubby_ssh, that
    # means that I'm always tapping the gnubby, and other related annoyances.
    # So I've disabled this for now, but there probably is a way to send this
    # back across the ssh channel under its authorization, which would eliminate
    # repeated validation. Someday...
    #echo "$cmd[@]" | exec ssh $REMOTE_HOST cmd_notify -t $LC_TTY:t $tm $st -
    exit 0
fi

zstyle -g fmc ':cmd_notify:' frontmost-command
eval "frontmost=(`$fmc`)"
fmapp=$frontmost[1]
fmwin=$frontmost[2]
if zstyle -m ':cmd_notify:' silent-frontmost "$fmapp" || [[ $fmwin =~ "$tty" ]]; then
    # Be silent about commands if this is frontmost
    exit 0
fi

local -i secs=$((tm % 60))
local -i mins=$((tm / 60))
local timestr
timestr=`printf 'Time: %d:%02d' $mins $secs`
(
    echo $timestr
    echo Status: $st
) | growlnotify -s -- "$cmd[@]"
